using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Json;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using Ai_Company.Options;
using Application.Service.Interfaces;
using Domain.Entitites;
using Google.Api.Gax.Grpc;   
using Microsoft.Extensions.Options;
using static Google.Api.Gax.Grpc.ClientHelper;
using System.Text.Json.Serialization;

namespace Application.Service
{

    public class GeminiService : IGeminiService
    {
        private readonly HttpClient _http;
        private readonly IOptionsSnapshot<GeminiOptions> _options;
        private const string ApiBaseUrlTemplate = "https://generativelanguage.googleapis.com/v1beta/models/{0}:generateContent";

        public GeminiService(HttpClient http, IOptionsSnapshot<GeminiOptions> options)
        {
            _http = http;
            _options = options;
        }

        public async Task<string> GenerateContentAsync(List<Chat> history, AIModelConfig modelConfig = null)
        {
            if (history == null || !history.Any())
            {
                throw new ArgumentException("Chat history (even for a single message) cannot be empty.");
            }

            // Use ModelConfig if provided, otherwise use defaults
            var temperature = modelConfig?.Temperature ?? 0.9f;
            var maxOutputTokens = modelConfig?.MaxOutputTokens ?? 65536;
            var topP = modelConfig?.TopP;
            var topK = modelConfig?.TopK;
            var modelName = modelConfig?.ModelName ?? "gemini-2.5-flash";
            var apiKey = modelConfig?.ApiKey;

            // Fallback to config if ModelConfig doesn't have ApiKey
            if (string.IsNullOrEmpty(apiKey))
            {
                apiKey = _options.Value?.ApiKey;
            }
            if (string.IsNullOrEmpty(apiKey))
            {
                throw new InvalidOperationException("Gemini API key is not configured. Please check appsettings.json or ModelConfig");
            }

            var requestBody = new GeminiRequest
            {
                Contents = history.Select(m => new GeminiContent
                {
                    Role = m.Role,
                    Parts = new[] { new GeminiPart { Text = m.Text } }.ToList()
                }).ToList(),
                GenerationConfig = new GenerationConfig
                {
                    Temperature = temperature,
                    MaxOutputTokens = maxOutputTokens,
                    TopP = topP,
                    TopK = topK,
                    ResponseMimeType = "text/plain"
                }
            };

            var json = JsonSerializer.Serialize(requestBody, new JsonSerializerOptions { WriteIndented = false });
            var content = new StringContent(json, Encoding.UTF8, "application/json");

            var apiBaseUrl = string.Format(ApiBaseUrlTemplate, modelName);
            var requestUri = $"{apiBaseUrl}?key={apiKey}";
            var response = await _http.PostAsync(requestUri, content);

            response.EnsureSuccessStatusCode();

            var responseString = await response.Content.ReadAsStringAsync();

            try
            {
                var geminiResponse = JsonSerializer.Deserialize<GeminiResponse>(responseString);

                // Try get first text part
                var generatedText = geminiResponse?.Candidates?
                                                 .FirstOrDefault()?
                                                 .Content?
                                                 .Parts?
                                                 .FirstOrDefault(p => !string.IsNullOrEmpty(p.Text))?
                                                 .Text;

                if (string.IsNullOrEmpty(generatedText))
                {
                    // Fallback: return raw to help debug cases where model returns non-text parts or is blocked
                    Console.WriteLine($"[Gemini] Empty text response. Raw: {responseString}");
                    return "No response generated by Gemini.";
                }

                return generatedText;
            }
            catch (JsonException ex)
            {
                Console.WriteLine($"JSON parsing error: {ex.Message}");
                Console.WriteLine($"Raw Gemini response: {responseString}");
                throw new InvalidOperationException("Failed to parse Gemini API response.", ex);
            }
        }

        public async Task<string> GenerateResponseAsync(string context, AI_Configure aiConfigure, AIModelConfig modelConfig = null)
        {
            try
            {
                // Use ModelConfig if provided, otherwise use defaults
                var temperature = modelConfig?.Temperature ?? 0.85f;
                var maxOutputTokens = modelConfig?.MaxOutputTokens ?? 8192;
                var topP = modelConfig?.TopP;
                var topK = modelConfig?.TopK;
                var modelName = modelConfig?.ModelName ?? "gemini-2.5-flash";
                var apiKey = modelConfig?.ApiKey;

                // Fallback to config if ModelConfig doesn't have ApiKey
                if (string.IsNullOrEmpty(apiKey))
                {
                    apiKey = _options.Value?.ApiKey;
                }
                if (string.IsNullOrEmpty(apiKey))
                {
                    throw new InvalidOperationException("Gemini API key is not configured. Please check appsettings.json or ModelConfig");
                }

                // Build system instruction as Content object if Rules exist
                GeminiContent systemInstruction = null;
                if (!string.IsNullOrWhiteSpace(aiConfigure?.Rules))
                {
                    systemInstruction = new GeminiContent
                    {
                        Parts = new List<GeminiPart>
                        {
                            new GeminiPart { Text = aiConfigure.Rules }
                        }
                    };
                }

                var requestBody = new GeminiRequest
                {
                    Contents = new List<GeminiContent>
                    {
                        new GeminiContent
                        {
                            Role = "user",
                            Parts = new List<GeminiPart>
                            {
                                new GeminiPart { Text = context }
                            }
                        }
                    },
                    SystemInstruction = systemInstruction,
                    GenerationConfig = new GenerationConfig
                    {
                        Temperature = temperature,
                        MaxOutputTokens = maxOutputTokens,
                        TopP = topP,
                        TopK = topK,
                        ResponseMimeType = "text/plain"
                    }
                };

                var json = JsonSerializer.Serialize(requestBody, new JsonSerializerOptions { WriteIndented = false });
                var content = new StringContent(json, Encoding.UTF8, "application/json");

                var apiBaseUrl = string.Format(ApiBaseUrlTemplate, modelName);
                var response = await _http.PostAsync($"{apiBaseUrl}?key={apiKey}", content);
                var responseString = await response.Content.ReadAsStringAsync();

                if (!response.IsSuccessStatusCode)
                {
                    throw new HttpRequestException($"Gemini API error: {response.StatusCode} - {responseString}");
                }

                var responseObj = JsonSerializer.Deserialize<GeminiResponse>(responseString);
                var generatedText = responseObj?.Candidates?
                                              .FirstOrDefault()?
                                              .Content?
                                              .Parts?
                                              .FirstOrDefault(p => !string.IsNullOrEmpty(p.Text))?
                                              .Text;

                if (string.IsNullOrEmpty(generatedText))
                {
                    Console.WriteLine($"[Gemini] Empty text response. Raw: {responseString}");
                    return "No response generated by Gemini.";
                }

                return generatedText;
            }
            catch (Exception ex)
            {
                return $"Error generating response: {ex.Message}";
            }
        }
        
        public class GeminiRequest
        {
            [JsonPropertyName("contents")]
            public List<GeminiContent> Contents { get; set; } = new List<GeminiContent>();

            [JsonPropertyName("systemInstruction")]
            public GeminiContent? SystemInstruction { get; set; }

            [JsonPropertyName("generationConfig")]
            public GenerationConfig? GenerationConfig { get; set; }
        }

        public class GenerationConfig
        {
            [JsonPropertyName("temperature")]
            public float Temperature { get; set; }

            [JsonPropertyName("maxOutputTokens")]
            public int MaxOutputTokens { get; set; }

            [JsonPropertyName("topP")]
            public float? TopP { get; set; }

            [JsonPropertyName("topK")]
            public int? TopK { get; set; }

            // Some models (e.g., flash) prefer explicit response mime type
            [JsonPropertyName("response_mime_type")]
            public string? ResponseMimeType { get; set; }
        }

        public class GeminiContent
        {
            [JsonPropertyName("role")]
            public string Role { get; set; }

            [JsonPropertyName("parts")]
            public List<GeminiPart> Parts { get; set; } = new List<GeminiPart>();
        }

        public class GeminiPart
        {
            [JsonPropertyName("text")]
            public string Text { get; set; }
        }

        public class GeminiResponse
        {
            [JsonPropertyName("candidates")]
            public List<GeminiCandidate>? Candidates { get; set; }
        }

        public class GeminiCandidate
        {
            [JsonPropertyName("content")]
            public GeminiContent? Content { get; set; }
        }

        // --- Internal Chat Message DTO (simplified, ConversationId not strictly needed for stateless) ---
        public class Chat
        {
            public string Role { get; set; } // "user" or "model"
            public string Text { get; set; }
        }
    }
}